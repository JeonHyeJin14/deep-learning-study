# 1. 판다스
- 파이썬 데이터 처리를 위한 라이브러리

```python
import pandas as pd
```

- 데이터 구조 : 시리즈, 데이터 프레임, 패널

## a) 시리즈
- 1차원 배열의 값에 각 값에 대응되는 인덱스를 부여할 수 있는 구조를 갖고 있음
- index와 values로 구성
```python
sr = pd.Series([17000, 18000, 1000, 5000],
               index=["피자", "치킨", "콜라", "맥주"])
print('시리즈 출력 :')
print('-'*15)
print(sr)
```
```python
시리즈 출력 :
---------------
피자    17000
치킨    18000
콜라     1000
맥주     5000
dtype: int64
```
values와 index를 출력함

```python
print('시리즈의 값 : {}'.format(sr.values))
print('시리즈의 인덱스 : {}'.format(sr.index))

시리즈의 값 : [17000 18000  1000  5000]
시리즈의 인덱스 : Index(['피자', '치킨', '콜라', '맥주'], dtype='object')
```
### format() 함수
- 문자열 포맷팅 : {}가 비어있고 .format(sr.values)가 호출되면 중괄호가 sr.values로 대체됨

  
## b) 데이터 프레임 (data frame)

- 2차원의 리스트를 매개변수로 전달한다.
- 행과 열 인덱스 존재
- index, values, columns 구성

```python
values = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
index = ['one', 'two', 'three']
columns = ['A', 'B', 'C']

df = pd.DataFrame(values, index=index, columns=columns)

print('데이터프레임 출력 :')
print('-'*18)
print(df)

데이터프레임 출력 :
------------------
       A  B  C
one    1  2  3
two    4  5  6
three  7  8  9
```

- 생성된 데이터프레임으로부터 인덱스, 값, 열을 각각 출력

```python
print('데이터프레임의 인덱스 : {}'.format(df.index))
print('데이터프레임의 열이름: {}'.format(df.columns))
print('데이터프레임의 값 :')
print('-'*18)
print(df.values)


데이터프레임의 인덱스 : Index(['one', 'two', 'three'], dtype='object')
데이터프레임의 열이름: Index(['A', 'B', 'C'], dtype='object')
데이터프레임의 값 :
------------------
[[1 2 3]
 [4 5 6]
 [7 8 9]]
```

## c) 데이터 프레임의 생성
- 리스트, 시리즈, 딕셔너리, 넘파이의 ndarrays 또 다른 데이터 프레임으로부터 생성가능

```python
# 리스트로 생성하기
data = [
    ['1000', 'Steve', 90.72], 
    ['1001', 'James', 78.09], 
    ['1002', 'Doyeon', 98.43], 
    ['1003', 'Jane', 64.19], 
    ['1004', 'Pilwoong', 81.30],
    ['1005', 'Tony', 99.14],
]

df = pd.DataFrame(data)
print(df)

      0         1      2
0  1000     Steve  90.72
1  1001     James  78.09
2  1002    Doyeon  98.43
3  1003      Jane  64.19
4  1004  Pilwoong  81.30
5  1005      Tony  99.14
```

- 생성된 데이터프레임에 columns 이름을 지정

```python
df= pd.DataFrame(data, columns = ['학번','이름','점수'])
print(df)

     학번        이름     점수
0  1000     Steve  90.72
1  1001     James  78.09
2  1002    Doyeon  98.43
3  1003      Jane  64.19
4  1004  Pilwoong  81.30
5  1005      Tony  99.14
```

```python
# 딕셔너리로 생성하기
data = {
    '학번' : ['1000', '1001', '1002', '1003', '1004', '1005'],
    '이름' : [ 'Steve', 'James', 'Doyeon', 'Jane', 'Pilwoong', 'Tony'],
    '점수': [90.72, 78.09, 98.43, 64.19, 81.30, 99.14]
    }

df = pd.DataFrame(data)
print(df)


     학번        이름     점수
0  1000     Steve  90.72
1  1001     James  78.09
2  1002    Doyeon  98.43
3  1003      Jane  64.19
4  1004  Pilwoong  81.30
5  1005      Tony  99.14

```

## d) 데이터프레임 조회하기
- df.head(n) : 앞 부분 n개 보기
- df.tail(n) : 뒷 부분 n개 보기
- df['열 이름'] : 해당되는 열 조회

```python
# '학번'에 해당되는 열을 보기
print(df['학번'])

0    1000
1    1001
2    1002
3    1003
4    1004
5    1005
Name: 학번, dtype: object
```


# 2. 넘파이 (Numpy)
- 수치 데이터를 다루는 파이썬 패키지
- 다차원 행렬 자료구조인 ndarray를 통해서 벡터 및 행렬을 사용하는 선형 대수 계산에서 주로 사용됨
- 편의성 뿐 아니라 속도 면에서 순수 파이썬에 비해 압도적으로 빠름

  ```python
  pip install numpy
  import numpy as np
  ```

## a) np.array()
- 리스트, 튜플, 어레이로부터 ndarray를 생성함
```python
# 1차원 배열
vec = np.array([1, 2, 3, 4, 5])
print(vec)

[1 2 3 4 5]

# 2차원 배열
mat = np.array([[10, 20, 30], [ 60, 70, 80]]) 
print(mat)


[[10 20 30]
 [60 70 80]]

print('vec의 타입 :',type(vec))
print('mat의 타입 :',type(mat))

vec의 타입 : <class 'numpy.ndarray'>
mat의 타입 : <class 'numpy.ndarray'>
```

```python
print('vec의 축의 개수 :',vec.ndim) # 축의 개수 출력
print('vec의 크기(shape) :',vec.shape) # 크기 출력

vec의 축의 개수 : 1
vec의 크기(shape) : (5,)

print('mat의 축의 개수 :',mat.ndim) # 축의 개수 출력
print('mat의 크기(shape) :',mat.shape) # 크기 출력

mat의 축의 개수 : 2
mat의 크기(shape) : (2, 3)
```

## b) ndarray의 초기화
- np.zeros((n,m)) : n*m 배열의 모든 원소에 0 삽입
- np.ones((n,m)) : n*m 배열의 모든 원소에 1 삽입
- np.full((n,m), k) : n*m 배열에 사용자가 지정한 k값 삽입
- np.eye(n) : 대각선으로는 1이고 나머지는 0인 n*n  2차원 배열 생성
- np.random.random((n,m)) : 임의의 값으로 채워진 n*m 배열 생성

## c) np.arange()
- np.arange(n) : 0부터 n-1까지의 값을 가지는 배열 생성
- np.arange(i, j, k) : i부터 j-1까지 k씩 증가하는 배열 생성

## d) np.reshape()
- 내부 데이터는 변경하지 않으면서 배열의 구조만 변경
- np.array(np.arange(30)).reshape((5,6)) : 0부터 29까지의 숫자를 생성하는 arange(30) 수행 후 원소의 개수가 30개이므로 5행 6열의 행렬로 변경
  <img width="258" height="193" alt="image" src="https://github.com/user-attachments/assets/0a944051-e88e-4ada-9008-eed7b9c0a0b4" />


## e) Numpy 슬라이싱
- 특정 행이나 열들의 원소들을 접근 가능
```python
mat = np.array([[1, 2, 3], [4, 5, 6]])
print(mat)

[[1 2 3]
 [4 5 6]]

# 첫번째 행 출력
slicing_mat = mat[0, :]
print(slicing_mat)

[1 2 3]

# 두번째 열 출력
slicing_mat = mat[:, 1]
print(slicing_mat)

[2 5]
```

## f) Numpy 정수 인덱싱
- 슬라이싱을 사용하면 배열로부터 부분 배열을 추출할 수 있짖만 연속적이지 않은 원소로 배열을 만들 경우 슬라이싱으로는 만들 수 없음
```python
mat = np.array([[1,2], [4,5], [7,8]])

#1행 0열의 원소
mat[1,0]

# mat[[2행, 1행],[0열, 1열]]
indexing_mat=mat[[2,1],[0, 1]]
```

## g) Numpy 연산
- np.add(x, y) = x+y
- np.subtract(x, y) = x-y
- np.multiply(x, y) = x * y
- np.divide(x, y) = x/y
- np.dot(mat1, mat2) = 행렬곱

# 3. 맷플롯립 (Matplotlib)
- 차트나 플롯으로 시각화하는 패키지
- 데이터 분석 이전에 데이터 이해를 위한 시각화나 데이터 분석 후 결과를 시각화 하기 위해 사용

```python
pip install matplotlib
import matplotlib.pyplot as plt
```

## a) 라인 플롯
- 주피터 노트북에서는 show()를 사용하지 않아도 그래프 자동 렌더링 되지만 다른 환경에서는 사용해야함
```python
plt.title('test')
plt.plot([1,2,3,4],[2,4,8,6])
plt.show()
```
<img width="324" height="243" alt="image" src="https://github.com/user-attachments/assets/37af6022-8e34-49a7-b299-52cad8ab6893" />


## b) 축 레이블 삽입 
```python
plt.title('test')
plt.plot([1,2,3,4],[2,4,8,6])
plt.xlabel('hours')
plt.ylabel('score)
plt.show()
```
<img width="348" height="247" alt="image" src="https://github.com/user-attachments/assets/0433ffdf-ff30-4198-b9c5-62b511895ab0" />

## c) 라인 추가와 범례 삽입
```python
plt.title('students')
plt.plot([1,2,3,4],[2,4,8,6])
plt.plot([1.5,2.5,3.5,4.5],[3,5,8,10]) # 라인 새로 추가
plt.xlabel('hours')
plt.ylabel('score')
plt.legend(['A student', 'B student']) # 범례 삽입
plt.show()
```
<img width="344" height="242" alt="image" src="https://github.com/user-attachments/assets/4197ff37-a1d0-466d-95f3-7743131001c0" />


